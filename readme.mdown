# Stubble
### Trimmed down {{mustache}} templates in .NET
[![Build Status](https://img.shields.io/appveyor/ci/Romanx/Stubble.svg?style=flat-square)](https://ci.appveyor.com/project/Romanx/stubble/)
[![Coverage Status](https://img.shields.io/coveralls/Romanx/Stubble.svg?style=flat-square)](https://coveralls.io/r/Romanx/Stubble)
[![Prerelease Build Status](https://img.shields.io/nuget/vpre/Stubble.Core.svg?style=flat-square&label=nuget%20pre)](https://www.nuget.org/packages/Stubble.Core/)
[![Build Status](https://img.shields.io/nuget/v/Stubble.Core.svg?style=flat-square)](https://www.nuget.org/packages/Stubble.Core/)

Stubble is an implementation of the [Mustache](http://mustache.github.com/) template system in C# (but is usable from any .NET language).

For a language-agnostic overview of mustache's template syntax, see the `mustache(5)` [manpage](http://mustache.github.com/mustache.5.html).

Stubble is tested against the mustache specification and is `v.1.1.2, including lambdas` compliant, this means that your templates in other languages will work with Stubble provided they match the spec!

It is licenced under the MIT License which can be found [here.](/licence.md)

### Why should I use Stubble?
Stubble is designed to be a spec compliant mustache renderer with only the bare essentials, *you could say the rest has been trimmed down!*

Stubble provides no methods of finding your templates, no complicated logic for getting values from your objects or special types, no non-spec tags for rendering or logic and only the nessaries to make it a simple and fast parser and renderer.

### Okay I'm convinced, how do I get it and use it?
At the moment Stubble is in alpha but please feel free to grab it from the pre-release feed on nuget.org by clicking on the badge above! Another option for the more adventurious is to download the source and build it yourself.

For how to use Stubble I'd recommend reading the how to use guide [here.](https://github.com/Romanx/Stubble/wiki)

### Performance
This is only the alpha release and these are simple tests against the closest comparable measure which is [Nustache](https://github.com/jdiamond/Nustache/).

There are three different test cases:

	- Nustache (RenderToString)
	- Stubble (Without Cache)
	- Stubble (With Cache)

Stubble caches its parsed templates for speed so one of the test cases is with this cache cleared after each render and another when it isn't. Nustache does no caching so the closest comparison in raw performance would be *Nustache vs Stubble (Without Cache)* graph below.

The testing was done over 100 iterations, over a set of increments (100 | 1,000 | 10,000 | 100,000 | 1,000,000) for each library. The results are stored as the total number of miliseconds taken to perform the number of actions, and then averaged over all the iterations for a final result for each library for each increment.

![image](https://docs.google.com/spreadsheets/d/1QRKCy1GkwvI-pZqQaqcEHRHxWTRkz0aFXSt4O-zgOIk/pubchart?oid=1781166596&format=image)
![image](https://docs.google.com/spreadsheets/d/1QRKCy1GkwvI-pZqQaqcEHRHxWTRkz0aFXSt4O-zgOIk/pubchart?oid=306204948&format=image)

*Note:* that the bars in each group of each graph are scaled so that the fastest library is 100.

The exact timings for these graphs is on Google Docs which will is available [here.](https://docs.google.com/spreadsheets/d/1QRKCy1GkwvI-pZqQaqcEHRHxWTRkz0aFXSt4O-zgOIk/edit?usp=sharing)

### Extensibility
Stubble exposes certain internal structures for Extensions to be added in a loosely coupled way. The access these endpoints you need to use the StubbleBuilder interface to build instance of Stubble, as this can be an expensive operation it should be performed once and the instance of Stubble should be stored and injected either statically or using Dependency Injection.

This is currently under development and with incomplete documentation. 
They will be better documented when these have been completed.

However simple descriptions of the endpoints are:

#### Defaults
Each of these maps have default values which are defined in their respective sections. These can be overwritten by passing in overriding Getters with the same Keys. 

**NOTE: This can break default functionality! and cause Stubble to fail catastrophically**

#### Value Getters
You can add your own ValueGetters for mapping how to retrive values from given types by a key. Stubble provides a set of defaults for:

- `IDictionary<string, object>`
- `IDictionary`
- `object`

You have to register a Func maping a Type which is used during value discovery. The Func has to be the type `Func<string, object, object>(key, value) => object`

#### Token Getters
Tokens in Stubble are resolved using a map of keys (e.g. **#**) to Functions which return instances of ParserOutput the base class for all Tokens in Stubble. By default the following are defined:
```csharp
{ "#", (s, tags) => new SectionToken() { TokenType = s, Tags = tags } },
{ "^", (s, tags) => new InvertedToken() { TokenType = s } },
{ ">", (s, tags) => new PartialToken() { TokenType = s } },
{ "&", (s, tags) => new UnescapedValueToken() { TokenType = s } },
{ "name", (s, tags) => new EscapedValueToken() { TokenType = s } },
{ "text", (s, tags) => new RawValueToken() { TokenType = s } }
```

The Getter functions recieve the TokenTag which is the parsed key (e.g. **#**) and the set of Tags that are active at the moment of parsing. These are used for lambdas and parsing the sections using the correct tags as they can be changed from the default.

To have your tags rendered you require `IRenderableToken`, and if you wish to use the LambdaInterpolation (which all non-section renderable tokens should be using) you should inherit from `InterpolationToken` which provides the utility method `InterpolateLambdaValueIfPossible`.

#### Truthyness Evaluation
There needs to be some way to add to the truthful-ness checks for an object, this is due to the separation of concerns and loosely coupled state of Stubble.

An example of why is is required is a Truthy check on DataTable would be that it has a Rows.Count > 0 to be truthy as it does not implement `IEnumerable`. See Nustache for this specific bug.

#### Template Loaders
While Stubble doesn't come with any template loaders by default it does provide an interface and extension points for you to provide your own or use one that has already been created in a separate package.

The implementation of this feature is heavily inspired by [bobthecow's](https://github.com/bobthecow/) implementation of loaders in [mustache.php](https://github.com/bobthecow/mustache.php/).

The Loaders provided are:

 - StringLoader : Simply passes through the given Template without any changes (*Default for TemplateLocator*)
 - CompositeLoader : Takes an array of `IStubbleLoader` and sequentially goes through them until a template is found.
   **NOTE: If no template is found at all an exception is thrown of type UnknownTemplateException**

Partials will be located from the dictionary passed to the Render method or from an `IStubbleLoader` instance added to the StubbleBuilder allowing you to add common Partials which will be accessable to all your templates.

### Why not use [Nustache](https://github.com/jdiamond/Nustache/) instead?
If Stubble doesn't do what you need then you should use Nustache! It's a great tool and provides the same base functionality as Stubble provides for the default Mustache spec *(I know because I'm a contributor and current maintainer of that project!)*.

However it does provide lots of extra features, such as a variety of input types, helpers and compliation which increases its complexity and some which are extensions to the Mustache spec (such as helpers). If you need any of those pieces of functionality I'd highly recommend you use Nustache... at least until there are Extensions for Stubble which provide the functionality your after!
